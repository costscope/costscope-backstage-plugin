/*
 Generates a concise summary of public API changes by diffing the baseline
 etc/costscope-backstage-plugin.api.md against the temp report generated by API Extractor.
 Intended for CI PR annotation. Prints a Markdown message to stdout and writes
 it to api-diff.md for use by comment actions.
*/
const { spawnSync } = require('node:child_process');
const fs = require('node:fs');
const path = require('node:path');

const REPORT_FOLDER = path.resolve(__dirname, '..', 'etc');
const TEMP_FOLDER = path.resolve(__dirname, '..', 'temp');
const REPORT_FILE = 'costscope-backstage-plugin.api.md';
const BASELINE_PATH = path.join(REPORT_FOLDER, REPORT_FILE);
const TEMP_PATH = path.join(TEMP_FOLDER, REPORT_FILE);
const OUTPUT_MD = path.resolve(__dirname, '..', 'api-diff.md');
const OUTPUT_JSON = path.resolve(__dirname, '..', 'api-diff.json');

function runExtractor() {
  // Run extractor to generate temp report for comparison.
  // Use npx to reliably resolve local dependency binary in all environments.
  const proc = spawnSync('npx', ['-y', 'api-extractor', 'run', '--verbose'], {
    encoding: 'utf8',
    stdio: 'pipe',
  });
  // Emit output for debugging, but don't fail on non-zero (signature drift can trigger non-zero)
  const out = (proc.stdout || '') + (proc.stderr || '');
  process.stdout.write(out);
}

function readFileIfExists(p) {
  try {
    return fs.readFileSync(p, 'utf8');
  } catch (e) {
    return null;
  }
}

function extractTopLevelExports(markdown) {
  // Heuristic: collect single-line declarations in ts fences that start with 'export '
  // (e.g., 'export declare function foo(...', 'export { Bar }', etc.)
  const lines = markdown.split(/\r?\n/);
  const exports = new Set();
  let inFence = false;
  let fenceLang = '';
  for (const raw of lines) {
    const line = raw.trimEnd();
    if (line.startsWith('```')) {
      if (inFence) {
        inFence = false;
        fenceLang = '';
      } else {
        inFence = true;
        fenceLang = line.replace(/```+\s*/, '').trim();
      }
      continue;
    }
    if (!inFence || (fenceLang && !/^ts|typescript|tsdoc$/i.test(fenceLang))) continue;
    const l = line.trim();
    if (!l) continue;
    // capture top-level export lines and re-exports
    if (l.startsWith('export ')) {
      // normalize whitespace to make diffing robust
      const norm = l.replace(/\s+/g, ' ').trim();
      exports.add(norm);
    }
  }
  return exports;
}

function diffSets(a, b) {
  const onlyInA = [];
  for (const x of a) if (!b.has(x)) onlyInA.push(x);
  onlyInA.sort();
  return onlyInA;
}

function buildMarkdown({ added, removed, baselineMissing, tempMissing }) {
  const parts = [];
  parts.push('## Public API changes');
  if (baselineMissing) {
    parts.push('\nBaseline API report not found at `etc/' + REPORT_FILE + '`.');
  }
  if (tempMissing) {
    parts.push('\nTemp API report not found at `temp/' + REPORT_FILE + '`. Ensure API Extractor ran.');
  }
  if (!added.length && !removed.length) {
    parts.push('\nNo public API additions or removals detected.');
  } else {
    if (added.length) {
      parts.push('\n### Added');
      for (const s of added.slice(0, 100)) parts.push('- ' + s);
      if (added.length > 100) parts.push(`- ...and ${added.length - 100} more`);
    }
    if (removed.length) {
      parts.push('\n### Removed');
      for (const s of removed.slice(0, 100)) parts.push('- ' + s);
      if (removed.length > 100) parts.push(`- ...and ${removed.length - 100} more`);
    }
  }
  parts.push(`\n\nView full report diff by comparing \`etc/${REPORT_FILE}\` and \`temp/${REPORT_FILE}\`.`);
  return parts.join('\n');
}

function main() {
  // Ensure temp report exists
  runExtractor();

  const baselineMd = readFileIfExists(BASELINE_PATH);
  const tempMd = readFileIfExists(TEMP_PATH);

  const baselineMissing = !baselineMd;
  const tempMissing = !tempMd;
  let added = [], removed = [];

  if (baselineMd && tempMd) {
    const baseSet = extractTopLevelExports(baselineMd);
    const nextSet = extractTopLevelExports(tempMd);
    added = diffSets(nextSet, baseSet);
    removed = diffSets(baseSet, nextSet);
  }

  const md = buildMarkdown({ added, removed, baselineMissing, tempMissing });
  fs.writeFileSync(OUTPUT_MD, md, 'utf8');
  fs.writeFileSync(
    OUTPUT_JSON,
    JSON.stringify({ added, removed, baselineMissing, tempMissing }, null, 2),
    'utf8'
  );
  process.stdout.write('\n' + md + '\n');
}

main();
